msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2014-11-30 23:19+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"Plugin: Handle requests on all volumes, to add a new command working a"
"round the storage\"\n"
"layout: en\n"
"---"
msgstr ""
"---\n"
"title: \"プラグイン: 全てのパーティション上でリクエストを処理し、ストレージを操作する新たなコマンドを追加する\"\n"
"layout: ja\n"
"---"

msgid ""
"* TOC\n"
"{:toc}"
msgstr ""

msgid "## The goal of this tutorial"
msgstr "## チュートリアルのゴール"

msgid ""
"This tutorial aims to help you to learn how to develop plugins which do someth"
"ing dispersively for/in each volume, around the handling phase.\n"
"In other words, this tutorial describes *how to add a new simple command to th"
"e Droonga Engine*."
msgstr ""
"このチュートリアルでは、各ボリュームでのhadling phaseにおいて分散された処理を実行するプラグインを開発するための方法を学びます。\n"
"言い換えると、このチュートリアルでは *新しいコマンドをDroonga Engineに加える方法* を説明します。"

msgid "## Precondition"
msgstr "## 前提条件"

msgid "* You must complete the [tutorial for the adaption phase][adapter]."
msgstr "* [adaption phaseのチュートリアル][adapter]を完了していること。"

msgid "## Handling of requests"
msgstr "## リクエストのハンドリング"

msgid ""
"When a request is transferred from the adaption phase, the Droonga Engine ente"
"rs into the *processing phase*."
msgstr "適合フェーズからリクエストが転送されてくると、Droonga Engineは*処理フェーズ（processing phase）*に入ります。"

msgid ""
"In the processing phase, the Droonga Engine processes the request step by step"
".\n"
"One *step* is constructed from some sub phases: *planning phase*, *distributio"
"n phase*, *handling phase*, and *collection phase*."
msgstr ""
"処理フェーズでは、Droonga Engineはリクエストを「ステップ」ごとに段階的に処理します。\n"
"1つの *ステップ* は、*立案フェーズ*、*配布フェーズ*、*ハンドリング・フェーズ*、そして *集約フェーズ* という4つのフェーズから成り立っています"
"。"

msgid ""
" * At the *planning phase*, the Droonga Engine generates multiple sub steps to"
" process the request.\n"
"   In simple cases, you don't have to write codes for this phase, then there i"
"s just one sub step to handle the request.\n"
" * At the *distribution phase*, the Droonga Engine distributes task messages f"
"or the request, to multiple volumes.\n"
"   (It is completely done by the Droonga Engine itself, so this phase is not p"
"luggable.)\n"
" * At the *handling phase*, *each single volume simply processes only one dist"
"ributed task message as its input, and returns a result.*\n"
"   This is the time that actual storage accesses happen.\n"
"   Actually, some commands (`search`, `add`, `create_table` and so on) access "
"to the storage at the time.\n"
" * At the *collection phase*, the Droonga Engine collects results from volumes"
" to one unified result.\n"
"   There are some useful generic collectors, so you don't have to write codes "
"for this phase in most cases."
msgstr ""
" * *立案フェーズ* では、Droonga Engineはリクエストを処理するための複数のより小さなステップを生成します。\n"
"   単純なコマンドでは、このフェーズのためのコードを書く必要はありません。その場合には、リクエストを処理するためのステップが1つだけ存在するということにな"
"ります。\n"
" * *配布フェーズ* では、Droonga Engineは、リクエストを処理するためのタスクを表すメッセージを複数のボリュームに配布します。\n"
"   （この処理は完全にDroonga Engine自身によって行われるため、このフェーズはプラグインでの拡張はできません。）\n"
" * *ハンドリング・フェーズ*では、*各single volumeが、配布された単一のタスクメッセージを入力として処理して、その結果を返します*。\n"
"   ストレージへの読み書きが実際に発生するのは、この時になります。\n"
"   実際に、いくつかのコマンド（例えば `search`、`add`、`create_table` など）はこのタイミングでストレージの読み書きを行ってい"
"ます。\n"
" * *集約フェーズ* では、Droonga Engineが各ボリュームから返された結果を集約して、単一の結果に統合します。\n"
"   Droonga Engineは汎用の便利なcollectorをいくつか含んでいるため、多くの場合において、あなたはこのフェーズのためのコードを書く必要"
"はありません。"

msgid ""
"After all steps are finished, the Droonga Engine transfers the result to the p"
"ost adaption phase."
msgstr "すべてのステップの処理が終了すると、Droonga Engineは結果を後適合フェーズへと転送します。"

msgid ""
"A class to define operations at the handling phase is called *handler*.\n"
"Put simply, adding of a new handler means adding a new command."
msgstr ""
"ハンドリング・フェーズでの操作を定義するクラスは、*ハンドラー*と呼ばれます。\n"
"簡単に言うと、新しいハンドラーを追加するということは、新しいコマンドを追加するということを意味します。"

msgid "## Design a read-only command `countRecords`"
msgstr "## 読み取り専用のコマンド `countRecords` を設計する"

msgid ""
"Here, in this tutorial, we are going to add a new custom `countRecords` comman"
"d.\n"
"At first, let's design it."
msgstr ""
"このチュートリアルでは、新しい独自のコマンド `countRecords` を実装することにします。\n"
"まず、コマンドの仕様を設計しましょう。"

msgid ""
"The command reports the number of records about a specified table, for each si"
"ngle volume.\n"
"So it will help you to know how records are distributed in the cluster.\n"
"Nothing is changed by the command, so it is a *read-only command*."
msgstr ""
"このコマンドは、個々のsingle volumeにおける指定テーブルの全レコードの数を報告します。\n"
"これは、クラスタ内でどのようにレコードが分散されているかを調べる助けになるでしょう。\n"
"このコマンドはデータベースの内容を何も変更しないので、これは*読み取り専用のコマンド*と言うことができます。"

msgid "The request must have the name of one table, like:"
msgstr "リクエストは、以下のようにテーブル名を必ず1つ含まなくてはなりません"

msgid ""
"~~~json\n"
"{\n"
"  \"dataset\" : \"Starbucks\",\n"
"  \"type\"    : \"countRecords\",\n"
"  \"body\"    : {\n"
"    \"table\": \"Store\"\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Create a JSON file `count-records.json` with the content above.\n"
"We'll use it for testing."
msgstr ""
"上記のような内容のJSON形式のファイル `count-records.json` を作成します。\n"
"以降の検証では、このファイルを使い続けていきましょう。"

msgid ""
"The response must have number of records in the table, for each single volume."
"\n"
"They can be appear in an array, like:"
msgstr ""
"レスポンスは、各single volumeごとのそのテーブルにあるレコードの数を含んでいなくてはなりません。\n"
"これは以下のように、配列として表現できます："

msgid ""
"~~~json\n"
"{\n"
"  \"inReplyTo\": \"(message id)\",\n"
"  \"statusCode\": 200,\n"
"  \"type\": \"countRecords.result\",\n"
"  \"body\": [10, 10]\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"If there are 2 volumes and 20 records are stored evenly, the array will have t"
"wo elements like above.\n"
"It means that a volume has 10 records and another one also has 10 records."
msgstr ""
"ボリュームが2つある場合、20個のレコードが均等に保持されているはずなので、配列は上記のように2つの要素を持つことになるでしょう。\n"
"この例は、各ボリュームがレコードを10個ずつ保持している事を示しています。"

msgid ""
"We're going to create a plugin to accept such requests and return such respons"
"es."
msgstr "それでは、ここまでで述べたような形式のリクエストを受け付けて上記のようなレスポンスを返す、というプラグインを作っていきましょう。"

msgid "### Directory structure"
msgstr "### ディレクトリ構成"

msgid ""
"The directory structure for plugins are in same rule as explained in the [tuto"
"rial for the adaption phase][adapter].\n"
"Now let's create the `count-records` plugin, as the file `count-records.rb`. T"
"he directory tree will be:"
msgstr ""
"プラグインのディレクトリ構成は、[適合フェーズ用のプラグインのチュートリアル][adapter]での説明と同じ様式に則ります。\n"
"`count-records.rb` というファイルとして、`count-records` プラグインを作りましょう。ディレクトリツリーは以下のようになりま"
"す："

msgid ""
"~~~\n"
"lib\n"
"└── droonga\n"
"    └── plugins\n"
"            └── count-records.rb\n"
"~~~"
msgstr ""

msgid "Then, create a skeleton of a plugin as follows:"
msgstr "次に、以下のようにしてプラグインの骨組みを作ります："

msgid "lib/droonga/plugins/count-records.rb:"
msgstr ""

msgid ""
"~~~ruby\n"
"require \"droonga/plugin\""
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module CountRecordsPlugin\n"
"      extend Plugin\n"
"      register(\"count-records\")\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "### Define a \"step\" for the command"
msgstr "### コマンドのための「ステップ」を定義する"

msgid "Define a \"step\" for the new `countRecords` command, in your plugin. Like:"
msgstr "以下のようにして、プラグインの中で新しいコマンド `countRecords` のための「ステップ」を定義します："

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module CountRecordsPlugin\n"
"      extend Plugin\n"
"      register(\"count-records\")"
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"The `step.name` equals to the name of the command itself.\n"
"Currently we just define the name of the command.\n"
"That's all."
msgstr ""
"`step.name` の値は、コマンド自身の名前と同じです。\n"
"今のところは、コマンドの名前を定義しただけです。\n"
"それ以上のことはしていません。"

msgid "### Define the handling logic"
msgstr "### ハンドリングの仕方を定義する"

msgid ""
"The command has no handler, so it does nothing yet.\n"
"Let's define the behavior."
msgstr ""
"このコマンドはハンドラーを持っていないため、まだ何も処理が行われません。\n"
"それではコマンドの挙動を定義しましょう。"

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"        step.handler = :Handler\n"
"      end"
msgstr ""

msgid ""
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          [0]\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "The class `Handler` is a handler class for our new command."
msgstr "`Handler` というクラスは、新しいコマンドのためのハンドラークラスです。"

msgid ""
" * It must inherit a builtin-class `Droonga::Handler`.\n"
" * It implements the logic to handle requests.\n"
"   Its instance method `#handle` actually handles requests."
msgstr ""
" * ハンドラークラスは、組み込みのクラス `Droonga::Handler` を継承してなければなりません。\n"
" * ハンドラークラスは、リクエストをどのように扱うかの処理を実装します。\n"
"   インスタンスメソッド `#handle` が実際にリクエストを処理します。"

msgid ""
"Currently the handler does nothing and returns an result including an array of"
" a number.\n"
"The returned value is used to construct the response body."
msgstr ""
"現時点で、このハンドラーは何も処理を行わず、単に数値1つからなる配列を含む処理結果を返すだけです。\n"
"戻り値はレスポンスのbodyを組み立てるのに使われます。"

msgid ""
"The handler is bound to the step with the configuration `step.handler`.\n"
"Because we define the class `Handler` after `define_single_step`, we specify t"
"he handler class with a symbol `:Handler`.\n"
"If you define the handler class before `define_single_step`, then you can writ"
"e as `step.handler = Handler` simply.\n"
"Moreover, a class path string like `\"OtherPlugin::Handler\"` is also available."
msgstr ""

msgid ""
"Then, we also have to bind a collector to the step, with the configuration `st"
"ep.collector`."
msgstr ""

msgid ""
"~~~ruby\n"
"# (snip)\n"
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"        step.handler = :Handler\n"
"        step.collector = Collectors::Sum\n"
"      end\n"
"# (snip)\n"
"~~~"
msgstr ""

msgid ""
"The `Collectors::Sum` is one of built-in collectors.\n"
"It merges results returned from handler instances for each volume to one resul"
"t."
msgstr ""

msgid "### Activate the plugin with `catalog.json`"
msgstr "### `catalog.json`でプラグインを有効化する"

msgid ""
"Update catalog.json to activate this plugin.\n"
"Add `\"count-records\"` to `\"plugins\"`."
msgstr ""

msgid ""
"~~~\n"
"(snip)\n"
"      \"datasets\": {\n"
"        \"Starbucks\": {\n"
"          (snip)\n"
"          \"plugins\": [\"count-records\", \"groonga\", \"crud\", \"search\", \"dump\", \"s"
"tatus\"],\n"
"(snip)\n"
"~~~"
msgstr ""

msgid "### Run and test"
msgstr "### 実行と動作を確認する"

msgid ""
"Let's get Droonga started.\n"
"Note that you need to specify ./lib directory in RUBYLIB environment variable "
"in order to make ruby possible to find your plugin."
msgstr ""

msgid ""
"    # kill $(cat fluentd.pid)\n"
"    # RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon f"
"luentd.pid"
msgstr ""

msgid ""
"Then, send a request message for the `countRecords` command to the Droonga Eng"
"ine."
msgstr ""

msgid ""
"~~~\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      0,\n"
"      0,\n"
"      0\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"You'll get a response message like above.\n"
"Look at these points:"
msgstr ""

msgid ""
" * The `type` of the response becomes `countRecords.result`.\n"
"   It is automatically named by the Droonga Engine.\n"
" * The format of the `body` is same to the returned value of the handler's `ha"
"ndle` method."
msgstr ""

msgid "There are three elements in the array. Why?"
msgstr ""

msgid ""
" * Remember that the `Starbucks` dataset was configured with two replicas and "
"three sub volumes for each replica, in the `catalog.json` of [the basic tutori"
"al][basic].\n"
" * Because it is a read-only command, a request is delivered to only one repli"
"ca (and it is chosen at random).\n"
"   Then only three single volumes receive the command, so only three results a"
"ppear, not six.\n"
"   (TODO: I have to add a figure to indicate active nodes: [000, 001, 002, 010"
", 011, 012] => [000, 001, 002])\n"
" * The `Collectors::Sum` collects them.\n"
"   Those three results are joined to just one array by the collector."
msgstr ""

msgid ""
"As the result, just one array with three elements appears in the final respons"
"e."
msgstr ""

msgid "### Read-only access to the storage"
msgstr ""

msgid ""
"Now, each instance of the handler class always returns `0` as its result.\n"
"Let's implement codes to count up the number of records from the actual storag"
"e."
msgstr ""

msgid ""
"~~~ruby\n"
"# (snip)\n"
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          request = message.request\n"
"          table_name = request[\"table\"]\n"
"          table = @context[table_name]\n"
"          count = table.size\n"
"          [count]\n"
"        end\n"
"      end\n"
"# (snip)\n"
"~~~"
msgstr ""

msgid ""
"Look at the argument of the `handle` method.\n"
"It is different from the one an adapter receives.\n"
"A handler receives a message meaning a distributed task.\n"
"So you have to extract the request message from the distributed task by the co"
"de `request = message.request`."
msgstr ""

msgid ""
"The instance variable `@context` is an instance of `Groonga::Context` for the "
"storage of the corresponding single volume.\n"
"See the [class reference of Rroonga][Groonga::Context].\n"
"You can use any feature of Rroonga via `@context`.\n"
"For now, we simply access to the table itself by its name and read the value o"
"f its `size` method - it returns the number of records."
msgstr ""

msgid ""
"Then, test it.\n"
"Restart the Droonga Engine and send the request again."
msgstr ""

msgid ""
"~~~\n"
"# kill $(cat fluentd.pid)\n"
"# RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon fluen"
"td.pid\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      14,\n"
"      15,\n"
"      11\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid "Because there are totally 40 records, they are stored evenly like above."
msgstr ""

msgid "## Design a read-write command `deleteStores`"
msgstr ""

msgid "Next, let's add another new custom command `deleteStores`."
msgstr ""

msgid ""
"The command deletes records of the `Store` table, from the storage.\n"
"Because it modifies something in existing storage, it is a *read-write command"
"*."
msgstr ""

msgid "The request must have the condition to select records to be deleted, like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"dataset\" : \"Starbucks\",\n"
"  \"type\"    : \"deleteStores\",\n"
"  \"body\"    : {\n"
"    \"keyword\": \"Broadway\"\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Any record including the given keyword `\"Broadway\"` in its `\"key\"` is deleted "
"from the storage of all volumes."
msgstr ""

msgid ""
"Create a JSON file `delete-stores-broadway.json` with the content above.\n"
"We'll use it for testing."
msgstr ""

msgid "The response must have a boolean value to indicate \"success\" or \"fail\", like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"inReplyTo\": \"(message id)\",\n"
"  \"statusCode\": 200,\n"
"  \"type\": \"deleteStores.result\",\n"
"  \"body\": true\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"If the request is successfully processed, the `body` becomes `true`. Otherwise"
" `false`.\n"
"The `body` is just one boolean value, because we don't have to receive multipl"
"e results from volumes."
msgstr ""

msgid "### Directory Structure"
msgstr "### ディレクトリの構造"

msgid ""
"Now let's create the `delete-stores` plugin, as the file `delete-stores.rb`. T"
"he directory tree will be:"
msgstr ""

msgid ""
"~~~\n"
"lib\n"
"└── droonga\n"
"    └── plugins\n"
"            └── delete-stores.rb\n"
"~~~"
msgstr ""

msgid "lib/droonga/plugins/delete-stores.rb:"
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module DeleteStoresPlugin\n"
"      extend Plugin\n"
"      register(\"delete-stores\")\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "Define a \"step\" for the new `deleteStores` command, in your plugin. Like:"
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module DeleteStoresPlugin\n"
"      extend Plugin\n"
"      register(\"delete-stores\")"
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"deleteStores\"\n"
"        step.write = true\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"Look at a new configuration `step.write`.\n"
"Because this command modifies the storage, we must indicate it clearly."
msgstr ""

msgid "Let's define the handler."
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"deleteStores\"\n"
"        step.write = true\n"
"        step.handler = :Handler\n"
"        step.collector = Collectors::And\n"
"      end"
msgstr ""

msgid ""
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          request = message.request\n"
"          keyword = request[\"keyword\"]\n"
"          table = @context[\"Store\"]\n"
"          table.delete do |record|\n"
"            record.key =~ keyword\n"
"          end\n"
"          true\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"Remember, you have to extract the request message from the received task messa"
"ge."
msgstr ""

msgid ""
"The handler finds and deletes existing records which have the given keyword in"
" its \"key\", by the [API of Rroonga][Groonga::Table_delete]."
msgstr ""

msgid ""
"And, the `Collectors::And` is bound to the step by the configuration `step.col"
"lector`.\n"
"It is is also one of built-in collectors, and merges boolean values returned f"
"rom handler instances for each volume, to one boolean value."
msgstr ""

msgid ""
"Update catalog.json to activate this plugin.\n"
"Add `\"delete-stores\"` to `\"plugins\"`."
msgstr ""

msgid ""
"~~~\n"
"(snip)\n"
"      \"datasets\": {\n"
"        \"Starbucks\": {\n"
"          (snip)\n"
"          \"plugins\": [\"delete-stores\", \"count-records\", \"groonga\", \"crud\", \"se"
"arch\", \"dump\", \"status\"],\n"
"(snip)\n"
"~~~"
msgstr ""

msgid "Restart the Droonga Engine and send the request."
msgstr ""

msgid ""
"~~~\n"
"# kill $(cat fluentd.pid)\n"
"# RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon fluen"
"td.pid\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"deleteStores.result\",\n"
"    \"body\": true\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Because results from volumes are unified to just one boolean value, the respon"
"se's `body` is a `true`.\n"
"As the verification, send the request of `countRecords` command."
msgstr ""

msgid ""
"~~~\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      7,\n"
"      13,\n"
"      6\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Note, the number of records are smaller than the previous result.\n"
"This means that four or some records are deleted from each volume."
msgstr ""

msgid "## Conclusion"
msgstr "## まとめ"

msgid ""
"We have learned how to add a new simple command working around the data.\n"
"In the process, we also have learned how to create plugins working in the hand"
"ling phrase."
msgstr ""

msgid ""
"  [adapter]: ../adapter\n"
"  [basic]: ../basic\n"
"  [Groonga::Context]: http://ranguba.org/rroonga/en/Groonga/Context.html\n"
"  [Groonga::Table_delete]: http://ranguba.org/rroonga/en/Groonga/Table.html#de"
"lete-instance_method"
msgstr ""
