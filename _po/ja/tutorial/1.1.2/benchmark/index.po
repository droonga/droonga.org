msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2014-11-30 23:19+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"How to benchmark Droonga with Groonga?\"\n"
"layout: en\n"
"---"
msgstr ""
"---\n"
"title: \"DroongaとGroongaのベンチマークの取り方\"\n"
"layout: ja\n"
"---"

msgid ""
"* TOC\n"
"{:toc}"
msgstr ""

msgid ""
"<!--\n"
"this is based on https://github.com/droonga/presentation-droonga-meetup-1-intr"
"oduction/blob/master/benchmark/README.md\n"
"-->"
msgstr ""

msgid "## The goal of this tutorial"
msgstr "## チュートリアルのゴール"

msgid ""
"Learning steps to benchmark a [Droonga][] cluster and compare it to a [Groonga"
"][groonga] server."
msgstr "[Droonga][]クラスタのベンチマークを測定し、[Groonga][groonga]での結果と比較するまでの、一連の手順を学ぶこと。"

msgid "## Precondition"
msgstr "## 前提条件"

msgid ""
"* You must have basic knowledge and experiences to set up and operate an [Ubun"
"tu][] or [CentOS][] Server.\n"
"* You must have basic knowledge and experiences to use the [Groonga][groonga] "
"via HTTP.\n"
"* You must have basic knowledge to construct a [Droonga][] cluster.\n"
"  Please complete the [\"getting started\" tutorial](../groonga/) before this."
msgstr ""
"* [Ubuntu][]または[CentOS][]のサーバの操作に関する基本的な知識と経験があること。\n"
"* [Groonga][groonga]をHTTP経由で操作する際の基本的な知識と経験があること。\n"
"* [Droonga][]クラスタの構築手順について基本的な知識があること。\n"
"  このチュートリアルの前に、[「使ってみる」のチュートリアル](../groonga/)を完了しておいて下さい。"

msgid "## Why benchmarking?"
msgstr "## ベンチマークの必要性について"

msgid ""
"Because Droonga has compatibility to Groonga, you'll plan to migrate your appl"
"ication based on Groonga to Droonga.\n"
"Before that, you should benchmark Droonga and confirm that it is better altern"
"ative for your application."
msgstr ""
"DroongaはGroongaと互換性があるため、GroongaベースのアプリケーションをDroongaに移行することを検討することもあるでしょう。\n"
"そんな時は、実際に移行する前に、Droongaの性能を測定して、より良い移行先であるかどうかを確認しておくべきです。"

msgid ""
"Of course you may simply hope to know the difference in performance between Gr"
"oonga and Droonga.\n"
"Benchmarking will make it clear."
msgstr ""
"もちろん、単にGroongaとDroongaの性能差を知りたいと思うこともあるでしょう。\n"
"ベンチマークによって、差を可視化することができます。"

msgid "### How visualize the performance?"
msgstr "### 性能の可視化の方法"

msgid "There are two major indexes to indicate performance of a system."
msgstr "あるシステムの性能を表す指標としては、以下の2つが多く使われます。"

msgid ""
" * latency\n"
" * throughput"
msgstr ""
" * レイテンシー\n"
" * スループット"

msgid ""
"Latency is the response time, actual elapsed time between two moments: when th"
"e system receives a request, and when it returns a response.\n"
"In other words, for clients, it is the time to wait for each request.\n"
"At this index, the smaller is the better.\n"
"In general, latency becomes small for lightweight queries, small size database"
", or less clients."
msgstr ""
"レイテンシーとは、システムがリクエストを受け取ってからレスポンスを返すまでに実際にかかった応答時間のことです。\n"
"言い換えると、これは各リクエストについてクライアントが待たされた時間です。\n"
"この指標においては、数値は小さければ小さいほどよいです。\n"
"一般的に、クエリが軽い場合や、データベースのサイズが小さい場合、クライアント数が少ない場合に、レイテンシーは小さくなります。"

msgid ""
"Throughput means how many request can be processed in a time.\n"
"The performance index is described as \"*queries per second* (*qps*)\".\n"
"For example, if a Groonga server processed 10 requests in one second, that is "
"described as \"10qps\".\n"
"Possibly there are 10 users (clients), or, there are 2 users and each user ope"
"ns 5 tabs in his web browser.\n"
"Anyway, \"10qps\" means that the Groonga actually accepted and responded for 10 "
"requests while one second is passing."
msgstr ""
"スループットは、一度にどれだけの数のリクエストを捌けるかを意味するものです。\n"
"性能の指標は「*クエリ毎秒*（Queries Per Second, *qps*）」という単位で表されます。\n"
"例えば、あるGroongaサーバが1秒に10件のリクエストを処理できたとき、これを「10qps」と表現します。\n"
"10人のユーザ（クライアント）がいるのかもしれませんし、2人のユーザがそれぞれブラウザ上で5つのタブを開いているのかもしれません。\n"
"ともかく、「10qps」という数値は、1秒が経過する間にそのGroongaサーバが実際に10件のリクエストを受け付けて、レスポンスを返したということを意味し"
"ます。"

msgid ""
"You can run benchmark with the command `drnbench-request-response`, introduced"
" by the Gem package [drnbench]().\n"
"It measures both latency and throughput of the target service."
msgstr ""
"ベンチマークは、[drnbench]()というGemパッケージによって導入される`drnbench-request-response`コマンドで行うことがで"
"きます。\n"
"このツールは、計測対象のサービスについてレイテンシーとスループットの両方を計測できます。"

msgid "### How the benchmark tool measures the performance?"
msgstr "### ベンチマークツールはどのように性能を測定するのか"

msgid ""
"`drnbench-request-response` benchmarks the target service, by steps like follo"
"wing:"
msgstr "`drnbench-request-response`は、対象サービスの性能を以下のようにして計測します:"

msgid ""
" 1. The master process generates one virtual client.\n"
"    The client starts to send many requests to the target sequentially and fre"
"quently.\n"
" 2. After a while, the master process kills the client.\n"
"    Then he calculates minimum, maximum, and average elapsed time, from respon"
"se data.\n"
"    And, he counts up the number of requests actually processed by the target,"
" and reports it as \"qps\" of the single client case.\n"
" 3. The master process generates two virtual clients.\n"
"    They starts to send requests.\n"
" 4. After a while, the master process kills all clients.\n"
"    Then minimum, maximum, and average elapsed time is calculated, and total n"
"umber of processed requests sent by all clients is reported as \"qps\" of the tw"
"o clients case.\n"
" 5. Repeated with three clients, four clients ... and more progressively.\n"
" 6. Finally, the master process reports minimum/maximum/average elapsed time, "
"\"qps\", and other extra information for each case, as a CSV file like:"
msgstr ""
" 1. マスタープロセスが仮想クライアントを1つ生成する。\n"
"    このクライアントは即座に動き始め、対象サービスに対して多数のリクエストを連続して頻繁に送り続ける。\n"
" 2. しばらくしたら、マスタープロセスがクライアントを終了させる。\n"
"    そして、応答のデータから最小・最大・平均の経過時間を計算する。\n"
"    また、実際に対象サービスによって処理されたリクエストの件数を集計し、結果を1クライアントの場合のqps値として報告する。\n"
" 3. マスタープロセスが仮想クライアントを2つ生成する。\n"
"    これらのクライアントはリクエストを送り始める。\n"
" 4. しばらくしたら、マスタープロセスがすべてのクライアントを終了させる。\n"
"    そして、最小・最大・平均の経過時間を計算すると同時に、実際に対象サービスに処理されたリクエストの件数を集計し、結果を2クライアントの場合のqps値と"
"して報告する。\n"
" 5. 3クライアントの場合、4クライアントの場合……と、クライアント数を増やしながら繰り返す。\n"
" 6. 最後に、マスタープロセスが最小・最大・平均の経過時間、qps値、およびその他の情報をまとめたものを、以下のようなCSVファイルとして保存する:"

msgid ""
"    ~~~\n"
"    n_clients,total_n_requests,queries_per_second,min_elapsed_time,max_elapsed"
"_time,average_elapsed_time,200\n"
"    1,996,33.2,0.001773766,0.238031643,0.019765581680722916,100.0\n"
"    2,1973,65.76666666666667,0.001558398,0.272225481,0.020047345673086702,100."
"0\n"
"    4,3559,118.63333333333334,0.001531184,0.39942581,0.023357554419499882,100."
"0\n"
"    6,4540,151.33333333333334,0.001540704,0.501663069,0.042344890696916264,100"
".0\n"
"    8,4247,141.56666666666666,0.001483995,0.577100609,0.045836844514480835,100"
".0\n"
"    10,4466,148.86666666666667,0.001987089,0.604507078,0.06949704923846833,100"
".0\n"
"    12,4500,150.0,0.001782343,0.612596799,0.06902839555222215,100.0\n"
"    14,4183,139.43333333333334,0.001980711,0.60754769,0.1033681068718623,100.0"
"\n"
"    16,4519,150.63333333333333,0.00284654,0.653204575,0.09473386513387955,100."
"0\n"
"    18,4362,145.4,0.002330049,0.640683693,0.12581190483929405,100.0\n"
"    20,4228,140.93333333333334,0.003710795,0.662666076,0.1301649290901133,100."
"0\n"
"    ~~~"
msgstr ""

msgid "    You can analyze it, draw a graph from it, and so on."
msgstr "    この結果は、分析や、グラフ描画など、様々な使い方ができます。"

msgid ""
"    (Note: Performance results fluctuate from various factors.\n"
"    This is just an example on a specific version, specific environment.)"
msgstr ""
"    (注意: 性能測定の結果は様々な要因によって変動します。\n"
"    これはあくまで特定のバージョン、特定の環境での結果の例です。)"

msgid "### How read and analyze the result? {#how-to-analyze}"
msgstr "### 結果の読み方と分析の仕方 {#how-to-analyze}"

msgid "Look at the result above."
msgstr "上の例を見て下さい。"

msgid "#### HTTP response statuses"
msgstr "#### HTTPレスポンスのステータス"

msgid ""
"See the last columns named `200`.\n"
"It means the percentage of HTTP response statuses.\n"
"`200` is \"OK\", `0` is \"timed out\".\n"
"If clients got `400`, `500` and other errors, they will be also reported.\n"
"These information will help you to detect unexpected slow down."
msgstr ""
"最後の列、`200`を見て下さい。\n"
"これはHTTPレスポンスのステータスの割合を示しています。\n"
"`200`は「OK」、`0`は「タイムアウト」です。\n"
"`400`や`500`などのエラーレスポンスが得られた場合も、同様に報告されます。\n"
"これらの情報は、意図しない速度低下の原因究明に役立つでしょう。"

msgid "#### Latency"
msgstr "#### レイテンシー"

msgid ""
"Latency is easily analyzed - the smaller is the better.\n"
"The minimum and average elapsed time becomes small if any cache system is work"
"ing correctly on the target.\n"
"The maximum time is affected by slow queries, system's page-in/page-out, unexp"
"ected errors, and so on."
msgstr ""
"レイテンシーは簡単に分析できます。値が小さければ小さいほどよいと言えます。\n"
"対象サービスのキャッシュ機構が正常に動作している場合、最小と平均の応答時間は小さくなります。\n"
"最大応答時間は、重たいクエリ、システムのメモリのスワップの発生、意図しないエラーの発生などの影響を受けます。"

msgid ""
"A graph of latency also reveals the maximum number of effectively acceptable c"
"onnections in same time."
msgstr "レイテンシーのグラフは、有用な同時接続数の上限も明らかにします。"

msgid "![A graph of latency](/images/tutorial/benchmark/latency-groonga-1.0.8.png)"
msgstr "![レイテンシーのグラフ](/images/tutorial/benchmark/latency-groonga-1.0.8.png)"

msgid ""
"This is a graph of `average_elapsed_time`.\n"
"You'll see that the time is increased for over 4 clients.\n"
"What it means?"
msgstr ""
"これは`average_elapsed_time`のグラフです。\n"
"4クライアントを越えた所で経過時間が増加していることが見て取れるでしょう。\n"
"これは何を意味するのでしょうか？"

msgid ""
"Groonga can process multiple requests completely parallelly, until the number "
"of available processors.\n"
"When the computer has 4 processors, the system can process 4 or less requests "
"in same time, without extra latency.\n"
"And, if more requests are sent, 5th and later requests will be processed after"
" a preceding request is processed.\n"
"The graph confirms that the logical limitation is true."
msgstr ""
"Groongaは利用可能なプロセッサ数と同じ数だけのリクエストを完全に並行処理できます。\n"
"コンピュータのプロセッサ数が4である場合、そのシステムは4件以下のリクエストについては余計な待ち時間無しで同時に処理することができます。\n"
"それ以上の数のリクエストが来た場合、5番目以降のリクエストは、それ以前に受け付けたリクエストの処理完了後に処理されます。\n"
"先のグラフは、この理論上の上限が事実であることを示しています。"

msgid "#### Throughput"
msgstr "#### スループット"

msgid "A graph helps you to analyze throughput performance."
msgstr "スループット性能の分析にも、グラフが便利です。"

msgid ""
"![A graph of throughput](/images/tutorial/benchmark/throughput-groonga-1.0.8.p"
"ng)"
msgstr "![スループットのグラフ](/images/tutorial/benchmark/throughput-groonga-1.0.8.png)"

msgid ""
"You'll see that the \"qps\" stagnated around 150, for 6 or more clients.\n"
"This means that the target service can process 150 requests in one second, at "
"a maximum."
msgstr ""
"6クライアントを超えたあたりで、qps値が150前後で頭打ちになっているのを見て取れるでしょう。\n"
"これは、計測対象のサービスが1秒あたり最大で150件のリクエストを処理できるということを意味しています。"

msgid ""
"In other words, we can describe the result as: 150qps is the maximum throughpu"
"t performance of this system - generic performance of hardware, software, netw"
"ork, size of the database, queries, and more.\n"
"If the number of requests for your service is growing up and it is going to re"
"ach the limit, you have to do something about it - optimize queries, replace t"
"he computer with more powerful one, and so on."
msgstr ""
"言い直すと、この結果は「（ハードウェア、ソフトウェア、ネットワーク、データベースの大きさ、クエリの内容など、様々な要素をひっくるめた）このシステムのスループ"
"ットの性能限界は150qpsである」という風に読み取ることができます。\n"
"もしサービスに対するリクエストの件数が増加しつつあり、この限界に近づいているようであれば、クエリの最適化やコンピュータ自体のアップグレードなど、何らかの対策"
"を取ることを検討する必要があると言えます。"

msgid "#### Performance comparison"
msgstr "#### 性能の比較"

msgid ""
"Sending same request patterns to Groonga and Droonga, you can compare performa"
"nce of each system.\n"
"If Droonga has better performance, it will become good reason to migrate your "
"service from Groogna to Droonga."
msgstr ""
"同じリクエストのパターンをGroongaとDroongaに送ることで、各システムの性能を比較することができます。\n"
"もしDroongaの方が性能が良ければ、サービスのバックエンドをGroongaからDroongaに移行する根拠になり得ます。"

msgid ""
"Moreover, comparing multiple results from different number of Droogna nodes, y"
"ou can analyze the cost-benefit performance for newly introduced nodes."
msgstr "また、異なるノード数での結果を比較すると、新しくノードを追加する際のコストパフォーマンスを分析することもできます。"

msgid "## Prepare environments for benchmarking"
msgstr "## ベンチマーク環境を用意する"

msgid ""
"Assume that there are four [Ubuntu][] 14.04LTS servers for the new Droogna clu"
"ster and they can resolve their names each other:"
msgstr "新しいDroongaクラスタのために、以下の、互いにホスト名で名前解決できる4つの[Ubuntu][] 14.04LTSのサーバがあると仮定します:"

msgid ""
" * `192.168.100.50`, the host name is `node0`\n"
" * `192.168.100.51`, the host name is `node1`\n"
" * `192.168.100.52`, the host name is `node2`\n"
" * `192.168.100.53`, the host name is `node3`"
msgstr ""
" * `192.168.100.50`、ホスト名：`node0`\n"
" * `192.168.100.51`、ホスト名：`node1`\n"
" * `192.168.100.52`、ホスト名：`node2`\n"
" * `192.168.100.53`、ホスト名：`node3`"

msgid "One is client, others are Droonga nodes."
msgstr "1つはクライアント用で、残りの3つはDroongaノード用です。"

msgid "### Ensure an existing reference database (and the data source)"
msgstr "### 比較対照のデータベース（およびそのデータソース）を用意する"

msgid ""
"If you have any existing service based on Groonga, it becomes the reference.\n"
"Then you just have to dump all data in your Groonga database and load them to "
"a new Droonga cluster."
msgstr ""
"もしすでにGroongaベースのサービスを運用しているのであれば、それ自体が比較対照となります。\n"
"この場合、Groongaデータベースの内容すべてをダンプ出力し、新しく用意したDroongaクラスタに流し込みさえすれば、性能比較を行えます。"

msgid ""
"Otherwise - if you have no existing service, prepare a new reference database "
"with much data for effective benchmark.\n"
"The repository [wikipedia-search][] includes some helper scripts to construct "
"your Groonga server (and Droonga cluster), with [Japanese Wikipedia](http://ja"
".wikipedia.org/) pages."
msgstr ""
"特に運用中のサービスが無いということであれば、有効なベンチマークを取るために大量のデータを格納したデータベースを、対照として用意する必要があります。\n"
"[wikipedia-search][]リポジトリには、[Wikipedia日本語版](http://ja.wikipedia.org/)のページを格納した"
"Groongaサーバ（およびDroongaクラスタ）を用意する手助けとなるスクリプトが含まれています。"

msgid ""
"So let's prepare a new Groonga database including Wikipedia pages, on the `nod"
"e0`."
msgstr "では、Wikipediaのページを格納したGroongaデータベースを、`node0`のノードに準備しましょう。"

msgid ""
" 1. Determine the size of the database.\n"
"    You have to use good enough size database for benchmarking."
msgstr ""
" 1. データベースのサイズを決める。\n"
"    ベンチマーク測定のためには、十分に大きいサイズのデータベースを使う必要があります。"

msgid ""
"    * If it is too small, you'll see \"too bad\" benchmark result for Droonga, b"
"ecause the percentage of the Droonga's overhead becomes relatively too large.\n"
"    * If it is too large, you'll see \"too unstable\" result because page-in and"
" page-out of RAM will slow the performance down randomly.\n"
"    * If RAM size of all nodes are different, you should determine the size of"
" the database for the minimum size RAM."
msgstr ""
"    * もしデータベースが小さすぎれば、Droongaのオーバーヘッドが相対的に大きくなるため、Droongaにとって過度に悲観的なベンチマーク結果とな"
"るでしょう。\n"
"    * もしデータベースが大きすぎれば、メモリのスワップが発生してシステムの性能がランダムに劣化するために、過度に不安定なベンチマーク結果となるでしょう"
"。\n"
"    * 各ノードのメモリの搭載量が異なる場合、その中で最もメモリ搭載量が少ないノードに合わせてデータベースのサイズを決めるのが望ましいです。"

msgid ""
"    For example, if there are three nodes `node0` (8GB RAM), `node1` (8GB RAM)"
", and `node2` (6GB RAM), then the database should be smaller than 6GB.\n"
" 2. Set up the Groonga server, as instructed on [the installation guide](http:"
"//groonga.org/docs/install.html)."
msgstr ""
"    例えば、`node0` (8GB RAM), `node1` (8GB RAM), `node2` (6GB RAM)の3つのノードがあるとすれば、"
"データベースは6GBよりも小さくするべきです。\n"
" 2. [インストール手順](http://groonga.org/ja/docs/install.html)に従ってGroongaサーバをセットアップする"
"。"

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % sudo apt-get -y install software-properties-common\n"
"    % sudo add-apt-repository -y universe\n"
"    % sudo add-apt-repository -y ppa:groonga/ppa\n"
"    % sudo apt-get update\n"
"    % sudo apt-get -y install groonga\n"
"    ~~~"
msgstr ""

msgid ""
"    Then the Groonga becomes available.\n"
" 3. Download the archive of Wikipedia pages and convert it to a dump file for "
"Groonga, with the rake task `data:convert:groonga:ja`.\n"
"    You can specify the number of records (pages) to be converted via the envi"
"ronment variable `MAX_N_RECORDS` (default=5000)."
msgstr ""
"    これでGroongaを利用できるようになります。.\n"
" 3. Rakeのタスク `data:convert:groonga:ja` を使って、Wikipediaのページのアーカイブをダウンロードし、Groong"
"aのダンプファイルに変換する。\n"
"    変換するレコード（ページ）の数は、環境変数 `MAX_N_RECORDS`（初期値は5000）で指定することができます。"

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % cd ~/\n"
"    % git clone https://github.com/droonga/wikipedia-search.git\n"
"    % cd wikipedia-search\n"
"    % bundle install --path vendor/\n"
"    % time (MAX_N_RECORDS=1500000 bundle exec rake data:convert:groonga:ja \\\n"
"                                    data/groonga/ja-pages.grn)\n"
"    ~~~"
msgstr ""

msgid ""
"    Because the archive is very large, downloading and data conversion may tak"
"e time."
msgstr "    アーカイブは非常に大きいため、ダウンロードと変換には時間がかかります。"

msgid ""
"    After that, a dump file `~/wikipedia-search/data/groonga/ja-pages.grn` is "
"there.\n"
"    Create a new database and load the dump file to it.\n"
"    This also may take more time:"
msgstr ""
"    変換が終わったら、`~/wikipedia-search/data/groonga/ja-pages.grn`の位置にダンプファイルが生成されていま"
"す。\n"
"    新しいデータベースを作成し、ダンプファイルの内容を流し込みましょう。\n"
"    この操作にも時間がかかります:"

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % mkdir -p $HOME/groonga/db/\n"
"    % groonga -n $HOME/groonga/db/db quit\n"
"    % time (cat ~/wikipedia-search/config/groonga/schema.grn | groonga $HOME/g"
"roonga/db/db)\n"
"    % time (cat ~/wikipedia-search/config/groonga/indexes.grn | groonga $HOME/"
"groonga/db/db)\n"
"    % time (cat ~/wikipedia-search/data/groonga/ja-pages.grn | groonga $HOME/g"
"roonga/db/db)\n"
"    ~~~"
msgstr ""

msgid ""
"    Note: number of records affects to the database size.\n"
"    Just for information, my results are here:"
msgstr ""
"    注意: レコードの数がデータベースのサイズに影響します。\n"
"    参考までに、検証環境での結果を以下に示します:"

msgid ""
"     * 1.1GB database was constructed from 300000 records.\n"
"       Data conversion took 17 min, data loading took 6 min.\n"
"     * 4.3GB database was constructed from 1500000 records.\n"
"       Data conversion took 53 min, data loading took 64 min."
msgstr ""
"     * 30万件のレコードから、1.1GBのデータベースができました。\n"
"       データの変換には17分、流し込みには6分を要しました。\n"
"     * 150万件のレコードから、4.3GBのデータベースができました。\n"
"       データの変換には53分、流し込みには64分を要しました。"

msgid " 4. Start the Groonga as an HTTP server."
msgstr " 4. GroongaをHTTPサーバとして起動する"

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % groonga -p 10041 -d --protocol http $HOME/groonga/db/db\n"
"    ~~~"
msgstr ""

msgid "OK, now we can use this node as the reference for benchmarking."
msgstr "これで、このノードをベンチマーク測定の対照として使う準備が整いました。"

msgid "### Set up a Droonga cluster"
msgstr "### Droongaクラスタをセットアップする"

msgid ""
"Install Droonga to all nodes.\n"
"Because we are benchmarking it via HTTP, you have to install both services `dr"
"oonga-engine` and `droonga-http-server` for each node."
msgstr ""
"Droongaをすべてのノードにインストールします。\n"
"HTTP経由での動作をベンチマーク測定するので、`droonga-engine`と`droonga-http-server`の両方をインストールする必要があ"
"ります。"

msgid ""
"~~~\n"
"(on node0)\n"
"% host=node0\n"
"% curl https://raw.githubusercontent.com/droonga/droonga-engine/master/install"
".sh | \\\n"
"    sudo HOST=$host bash\n"
"% curl https://raw.githubusercontent.com/droonga/droonga-http-server/master/in"
"stall.sh | \\\n"
"    sudo ENGINE_HOST=$host HOST=$host PORT=10042 bash\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1,node2\n"
"% sudo service droonga-engine start\n"
"% sudo service droonga-http-server start\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node1)\n"
"% host=node1\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node2)\n"
"% host=node2\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"Note: to start `droonga-http-server` with a port number different from Groonga"
", we should specify another port `10042` via the `PORT` environment variable, "
"like above."
msgstr ""
"注意: `droonga-http-server`をGroongaとは別のポート番号で起動するために、ここでは`PORT`環境変数を使って上記のようにして`"
"10042`のポートで起動するように指定しています。"

msgid ""
"Make sure that Droonga's HTTP server is actualy listening the port `10042` and"
" it is working as a cluster with three nodes:"
msgstr ""
"DroongaのHTTPサーバが動作しており、`10042`番のポートを監視していることと、3つのノードからなるクラスタとして動作していることを確認しておき"
"ましょう:"

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo apt-get install -y jq\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node2:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid "### Synchronize data from Groonga to Droonga"
msgstr "### GroongaからDroongaへとデータを同期する"

msgid "Next, prepare the Droonga database."
msgstr "次に、Droongaのデータベースを用意します。"

msgid ""
"You can generate messages for Droonga from Groonga's dump result, by the `grn2"
"drn` command.\n"
"Install `grn2drn` Gem package to activate the command, to the Groonga server c"
"omputer."
msgstr ""
"`grn2drn`コマンドを使うと、Groongaのダンプ出力をDroonga用のメッセージに変換することができます。\n"
"コマンドを利用できるようにするために、Groongaサーバとなっているコンピュータに`grn2drn` Gemパッケージをインストールしましょう。"

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo gem install grn2drn\n"
"~~~"
msgstr ""

msgid ""
"And, the `grndump` command introduced as a part of `rroonga` Gem package provi"
"des ability to extract all data of an existing Groonga database, flexibly.\n"
"If you are going to extract data from an existing Groonga server, you have to "
"install `rroonga` before that."
msgstr ""
"また、`rroonga` Gemパッケージの一部として導入される`grndump`コマンドは、既存のGroongaのデータベースからすべてのデータを柔軟に取"
"り出す機能を提供しています。\n"
"もし既存のGroongaサーバからデータを取り出そうとしているのであれば、事前に`rroonga`をインストールしておく必要があります。"

msgid ""
"~~~\n"
"(on Ubuntu server)\n"
"% sudo apt-get -y install software-properties-common\n"
"% sudo add-apt-repository -y universe\n"
"% sudo add-apt-repository -y ppa:groonga/ppa\n"
"% sudo apt-get update\n"
"% sudo apt-get -y install libgroonga-dev\n"
"% sudo gem install rroonga\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on CentOS server)\n"
"# rpm -ivh http://packages.groonga.org/centos/groonga-release-1.1.0-1.noarch.r"
"pm\n"
"# yum -y makecache\n"
"# yum -y ruby-devel groonga-devel\n"
"# gem install rroonga\n"
"~~~"
msgstr ""

msgid "Then dump schemas and data separately and load them to the Droonga cluster."
msgstr "それでは、スキーマ定義とデータを別々にダンプ出力し、Droongaクラスタに流し込みましょう。"

msgid ""
"~~~\n"
"(on node0)\n"
"% time (grndump --no-dump-tables $HOME/groonga/db/db | \\\n"
"          grn2drn | \\\n"
"          droonga-send --server=node0 \\\n"
"                       --report-throughput)\n"
"% time (grndump --no-dump-schema --no-dump-indexes $HOME/groonga/db/db | \\\n"
"          grn2drn | \\\n"
"          droonga-send --server=node0 \\\n"
"                       --server=node1 \\\n"
"                       --server=node2 \\\n"
"                       --messages-per-second=100 \\\n"
"                       --report-throughput)\n"
"~~~"
msgstr ""

msgid ""
"Note that you must send requests for schema and indexes to just one endpoint.\n"
"Parallel sending of schema definition requests for multiple endpoints will bre"
"ak the database, because Droonga cannot sort schema changing commands sent to "
"each node in parallel."
msgstr ""
"スキーマ定義とインデックスの定義については単一のエンドポイントに送るように注意して下さい。\n"
"Droongaは複数のノードに並行してバラバラに送られたスキーマ変更コマンドをソートすることができないので、スキーマ定義のリクエストを複数のエンドポイントに"
"流し込むと、データベースが壊れてしまいます。"

msgid ""
"To reduce traffic and system load, you should specify maximum number of inpour"
"ing messages per second by the `--messages-per-second` option.\n"
"If too many messages rush into the Droonga cluster, they may overflow - Droong"
"a may eat up the RAM and slow down the system."
msgstr ""
"トラフィックとシステムの負荷を軽減するために、1秒あたりに流入するメッセージの量を`--messages-per-second`オプションで制限するようにし"
"てください。\n"
"大量のメッセージが一度にDroongaクラスタに流れ込むと、システムの限界を超えてしまい、Droongaがメモリを食い潰して、システムを非常に低速にしてしま"
"う恐れがあります。"

msgid ""
"This may take much time.\n"
"For example, with the option `--messages-per-second=100`, 1500000 records will"
" be synchronized in about 4 hours (we can estimate the required time like: `15"
"0000 / 100 / 60 / 60`)."
msgstr ""
"この操作にも時間がかかります。\n"
"例えば `--messages-per-second=100` と指定した場合、150万件のレコードを同期するにはだいたい4時間ほどかかります。（必要な時間"
"は `150000 / 100 / 60 / 60` のような計算式で見積もれます）"

msgid ""
"After all, now you have two HTTP servers: Groonga HTTP server with the port `1"
"0041`, and Droonga HTTP Servers with the port `10042`."
msgstr ""
"以上の手順により、`10041`ポートを監視するGroonga HTTPサーバと、`10042`ポートを監視するDroonga HTTPサーバの、2つのHT"
"TPサーバを用意できます。"

msgid "### Set up the client"
msgstr "### クライアントをセットアップする"

msgid "You must install the benchmark client to the computer."
msgstr "クライアントにするマシンには、ベンチマーク用のクライアントをインストールする必要があります。"

msgid "Assume that you use a computer `node3` as the client:"
msgstr "`node3`をクライアントとして使うと仮定します:"

msgid ""
"~~~\n"
"(on node3)\n"
"% sudo apt-get update\n"
"% sudo apt-get -y upgrade\n"
"% sudo apt-get install -y ruby curl jq\n"
"% sudo gem install drnbench\n"
"~~~"
msgstr ""

msgid "## Prepare request patterns"
msgstr "## リクエストパターンを用意する"

msgid "Let's prepare request pattern files for benchmarking."
msgstr "ベンチマーク用のリクエストパターンファイルを用意しましょう。"

msgid "### Determine the expected cache hit rate"
msgstr "### キャッシュヒット率を決める"

msgid "First, you have to determine the cache hit rate."
msgstr "まず、キャッシュヒット率を決める必要があります。"

msgid ""
"If you have any existing service based on Groonga, you can get the actual cach"
"e hit rate of the Groonga database via `status` command, like:"
msgstr ""
"もし既に運用中のGroongaベースのサービスがあるのであれば、以下のようにして、`status`コマンドを使ってGroongaデータベースのキャッシュヒッ"
"ト率を調べることができます:"

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/status\" | jq .\n"
"[\n"
"  [\n"
"    0,\n"
"    1412326645.19701,\n"
"    3.76701354980469e-05\n"
"  ],\n"
"  {\n"
"    \"max_command_version\": 2,\n"
"    \"alloc_count\": 158,\n"
"    \"starttime\": 1412326485,\n"
"    \"uptime\": 160,\n"
"    \"version\": \"4.0.6\",\n"
"    \"n_queries\": 1000,\n"
"    \"cache_hit_rate\": 0.5,\n"
"    \"command_version\": 1,\n"
"    \"default_command_version\": 1\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"The cache hit rate appears as `\"cache_hit_rate\"`.\n"
"`0.5` means 50%, then a half of responses are returned from cached results."
msgstr ""
"キャッシュヒット率は`\"cache_hit_rate\"`として返却されます。\n"
"`0.5`は50%という意味で、レスポンスのうちの半分がキャッシュされた結果に基づいて返されているということです。"

msgid ""
"If you have no existing service, you should assume that the cache hit rate bec"
"omes 50%."
msgstr "運用中のサービスが無いのであれば、ひとまずキャッシュヒット率は50％と過程すると良いでしょう。"

msgid ""
"To measure and compare performance of Groonga and Droonga properly, you should"
" prepare request patterns for benchmarking which make the cache hit rate near "
"the actual rate.\n"
"So, how do it?"
msgstr ""
"GroongaとDroongaの性能を正確に比較するためには、キャッシュヒット率が実際の値に近くなるようにリクエストパターンを用意する必要があります。\n"
"さて、どのようにすればよいのでしょうか？"

msgid ""
"You can control the cache hit rate by the number of unique request patterns, c"
"alculated with the expression:\n"
"`N = 100 / (cache hit rate)`, because Groonga and Droonga (`droonga-http-serve"
"r`) cache 100 results at a maximum by default.\n"
"When the expected cache hit rate is 50%, the number of unique requests is calc"
"ulated as: `N = 100 / 0.5 = 200`"
msgstr ""
"キャッシュヒット率は、`N = 100 ÷ (キャッシュヒット率)`という式で計算した、ユニーク（一意）なリクエストパターンの数で制御できます。\n"
"これは、GroongaとDroonga（`droonga-http-server`）が既定の状態で最大で100件までの結果をキャッシュするためです。\n"
"期待されるキャッシュヒット率が50%なのであれば、用意するべきユニークなリクエストの数は`N = 100 ÷ 0.5 = 200`と計算できます。"

msgid ""
"Note: if the actual rate is near zero, the number of unique requests becomes t"
"oo huge!\n"
"For such case you should carry up the rate to 0.01 (1%) or something."
msgstr ""
"注意: 実際のキャッシュヒット率が0に近い場合、必要となるユニークなリクエストの件数が巨大になってしまいます。\n"
"このような場合は、キャッシュヒット率を`0.01`（1%）程度と見なすとよいでしょう。"

msgid "### Format of request patterns file"
msgstr "### リクエストパターンファイルの書式"

msgid ""
"The format of the request patterns list for `drnbench-request-response` is the"
" plain text, a list of request paths for the host.\n"
"Here is a short example of requests for Groonga's `select` command:"
msgstr ""
"`drnbench-request-response`用のリクエストパターンのリストは、HTTPリクエストのパスのリストであるプレーンテキスト形式で作成しま"
"す。\n"
"以下はGroongaの`select`コマンド用のリクエストの一覧の例です:"

msgid ""
"~~~\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title&output_co"
"lumns=title&query=AAA\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title&output_co"
"lumns=title&query=BBB\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"If you have any existing service based on Groonga, the list should be generate"
"d from the actual access log, query log, and so on.\n"
"Patterns similar to actual requests will measure performance of your system mo"
"re effectively.\n"
"To generate 200 unique request patterns, you just have to collect 200 unique p"
"aths from your log."
msgstr ""
"もし既存のGroongaベースのサービスを運用しているのであれば、リクエストパターンのリストは、実際のアクセスログやクエリログなどから生成するのが望ましいで"
"す。\n"
"実際のリクエストに近いパターンであるほど、システムの性能をより有効に測定できます。\n"
"ユニークなリクエストパターンを200件作るには、ログからユニークなリクエスト先パスを200件収集してくればOKです。"

msgid ""
"Otherwise, you'll have to generate list of request paths from something.\n"
"See the next section."
msgstr ""
"運用中のサービスが無い場合は、何らかの方法でリクエストパスのリストを作る必要があります。\n"
"詳しくは事項を参照して下さい。"

msgid "### Prepare list of search terms"
msgstr "### 検索語句のリストを用意する"

msgid ""
"To generate 200 unique request patterns, you have to prepare 200 terms.\n"
"Moreover, all of terms must be effective search term for the Groonga database."
"\n"
"If you use randomly generated terms (like `P2qyNJ9L`, `Hy4pLKc5`, `D5eftuTp`, "
"...), you won't get effective benchmark result, because \"not found\" results wi"
"ll be returned for most requests."
msgstr ""
"200件のユニークなリクエストパターンを作るには、200個の語句を用意する必要があります。\n"
"しかも、それらはすべて実際にGroongaのデータベースで有効な検索結果を返すものでなくてはなりません。\n"
"もしランダムに生成した単語（例えば`P2qyNJ9L`, `Hy4pLKc5`, `D5eftuTp`……といった具合）を使った場合、ほとんどのリクエストに"
"対して「ヒット無し」という検索結果が返されてしまうため、有効なベンチマーク結果を得ることができません。"

msgid ""
"So there is a utility command `drnbench-extract-searchterms`.\n"
"It generates list of terms from Groonga's select result, like:"
msgstr ""
"こんな時のために、`drnbench-extract-searchterms`というユーティリティコマンドがあります。\n"
"これは、以下のようにしてGroongaの検索結果から単語のリストを生成します:"

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/select?command_version=2&table=Pages&limit=10&out"
"put_columns=title\" | \\\n"
"    drnbench-extract-searchterms\n"
"title1\n"
"title2\n"
"title3\n"
"...\n"
"title10\n"
"~~~"
msgstr ""

msgid ""
"`drnbench-extract-searchterms` extracts terms from the first column of records"
".\n"
"To collect 200 effective search terms, you just have to give a select result w"
"ith an option `limit=200`."
msgstr ""
"`drnbench-extract-searchterms`は検索結果のレコードの最初の列の値を単語として取り出します。\n"
"200件の有効な検索語句を得るには、単に`limit=200`と指定して検索結果を得ればOKです。"

msgid "### Generate request pattern file from given terms"
msgstr "### 与えられた語句からリクエストパターンファイルを生成する"

msgid ""
"OK, let's generate request patterns by `drnbench-extract-searchterms`, from a "
"select result."
msgstr "では、`drnbench-extract-searchterms`を使って、Groongaの検索結果からリクエストパターンを生成してみましょう。"

msgid ""
"~~~\n"
"% n_unique_requests=200\n"
"% curl \"http://node0:10041/d/select?command_version=2&table=Pages&limit=$n_uni"
"que_requests&output_columns=title\" | \\\n"
"    drnbench-extract-searchterms --escape | \\\n"
"    sed -r -e \"s;^;/d/select?command_version=2\\&table=Pages\\&limit=10\\&match_c"
"olumns=title,text\\&output_columns=snippet_html(title),snippet_html(text),categ"
"ories,_key\\&query_flags=NONE\\&sortby=title\\&drilldown=categories\\&drilldown_li"
"mit=10\\&drilldown_output_columns=_id,_key,_nsubrecs\\&drilldown_sortby=_nsubrec"
"s\\&query=;\" \\\n"
"    > ./patterns.txt\n"
"~~~"
msgstr ""

msgid "Note:"
msgstr "注意:"

msgid ""
" * You must escape `&` in the sed script with prefixed backslash, like `\\&`.\n"
" * You should specify the `--escape` option for `drnbench-extract-searchterms`"
".\n"
"   It escapes characters unsafe for URI strings.\n"
" * You should specify `query_flags=NONE` as a part of parameters, if you use s"
"earch terms by the `query` parameter.\n"
"   It forces ignoring of special characters in the `query` parameter, to Groon"
"ga.\n"
"   Otherwise you may see some errors from invalid queries."
msgstr ""
" * sedスクリプトの中の`&`は、前にバックスラッシュを置いて`\\&`のようにエスケープする必要があることに注意して下さい。\n"
" * `drnbench-extract-searchterms`コマンドには、`--escape`オプションを指定すると良いでしょう。\n"
"   この指定により、URIに含められない文字がエスケープされます。\n"
" * 得られた検索語句を`query`パラメータに使用する場合、`query_flags=NONE`も同時に指定すると良いでしょう。\n"
"   この指定により、Groongaは`query`パラメータの中に含まれる特殊文字を無視するようになります。\n"
"   この指定を忘れると、不正なクエリのエラーに遭遇することになるかもしれません。"

msgid "The generated file `patterns.txt` becomes like following:"
msgstr "生成されたファイル `patterns.txt` は以下のような内容になります:"

msgid ""
"~~~\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title,text&outp"
"ut_columns=snippet_html(title),snippet_html(text),categories,_key&query_flags="
"NONE&sortby=title&drilldown=categories&drilldown_limit=10&drilldown_output_col"
"umns=_id,_key,_nsubrecs&drilldown_sortby=_nsubrecs&query=AAA\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title,text&outp"
"ut_columns=snippet_html(title),snippet_html(text),categories,_key&query_flags="
"NONE&sortby=title&drilldown=categories&drilldown_limit=10&drilldown_output_col"
"umns=_id,_key,_nsubrecs&drilldown_sortby=_nsubrecs&query=BBB\n"
"...\n"
"~~~"
msgstr ""

msgid "## Run the benchmark"
msgstr "## ベンチマークを実行する"

msgid ""
"OK, it's ready to run.\n"
"Let's benchmark Groonga and Droonga."
msgstr ""
"以上で、準備が整いました。\n"
"それではGroongaとDroongaのベンチマークを取得してみましょう。"

msgid "### Benchmark Groonga"
msgstr "### Groongaのベンチマークを行う"

msgid ""
"First, run benchmark for Groonga as the reference.\n"
"Start Groonga's HTTP server before running, if you configured a node as a refe"
"rence Groonga server and daemon is stopped."
msgstr ""
"まず、比較対照としてGroongaでのベンチマーク結果を取得します。\n"
"`node0`を比較対照用のGroongaサーバとしてセットアップ済みで、GroongaのHTTPサーバが停止している場合には、ベンチマークの実行前にあらか"
"じめ起動しておいて下さい。"

msgid ""
"~~~\n"
"(on node0)\n"
"% groonga -p 10041 -d --protocol http $HOME/groonga/db/db\n"
"~~~"
msgstr ""

msgid "You can run benchmark with the command `drnbench-request-response`, like:"
msgstr "ベンチマークは以下の要領で、`drnbench-request-response`コマンドを実行すると測定できます:"

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0 \\\n"
"    --default-port=10041 \\\n"
"    --output-path=$PWD/groonga-result.csv\n"
"~~~"
msgstr ""

msgid "Important parameters are:"
msgstr "重要なパラメータは以下の通りです:"

msgid ""
" * `--step` is the number of virtual clients increased on each progress.\n"
" * `--start-n-clients` is the initial number of virtual clients.\n"
"   Even if you specify `0`, initially one client is always generated.\n"
" * `--end-n-clients` is the maximum number of virtual clients.\n"
"   Benchmark is performed progressively until the number of clients is reached"
" to this limit.\n"
" * `--duration` is the duration of each benchmark.\n"
"   This should be long enough to average out the result.\n"
"   `30` (seconds) seems good for my case.\n"
" * `--interval` is the interval between each benchmark.\n"
"   This should be long enough to finish previous benchmark.\n"
"   `10` (seconds) seems good for my case.\n"
" * `--request-patterns-file` is the path to the pattern file.\n"
" * `--default-hosts` is the list of host names of target endpoints.\n"
"   By specifying multiple hosts as a comma-separated list, you can simulate lo"
"ad balancing.\n"
" * `--default-port` is the port number of the target endpoint.\n"
" * `--output-path` is the path to the result file.\n"
"   Statistics of all benchmarks is saved as a file at the location."
msgstr ""
" * `--step` は、各段階で増やす仮想クライアントの数です。\n"
" * `--start-n-clients` は、仮想クライアントの最初の数です。\n"
"   例え`0`を指定したとしても、最初の実行時には必ず1つはクライアントが生成されます。\n"
" * `--end-n-clients` は、仮想クライアントの最大数です。\n"
"   ベンチマークは、クライアントの数がこの上限に達するまでの間繰り返し実行されます。\n"
" * `--duration` は、1回あたりのベンチマークの実行にかける時間です。\n"
"   この値は、結果が安定するまでに十分な長さの時間を指定するのが望ましいです。\n"
"   筆者の場合は`30`（秒）が最適でした。\n"
" * `--interval` は、ベンチマークの合間に設ける待ち時間です。\n"
"   これは、前回のベンチマークが終了するのに十分な長さの時間を指定するのが望ましいです。\n"
"   筆者の場合は`10`（秒）が最適でした。\n"
" * `--request-patterns-file` は、パターンファイルへのパスです。\n"
" * `--default-hosts` は、リクエストの送信先のホスト名の一覧です。\n"
"   複数のホストをカンマで区切って指定すると、ロードバランサーの動作をシミュレートすることもできます。\n"
" * `--default-port` は、リクエストの送信先のポート番号です。\n"
" * `--output-path` は、結果の出力先ファイルへのパスです。\n"
"   すべてのベンチマークの統計情報が、この位置にファイルとして保存されます。"

msgid ""
"While running, you should monitor the system status of the `node0`, by `top` o"
"r something.\n"
"If the benchmark elicits Groonga's performance correctly, Groonga's process us"
"es the CPU fully (for example, `400%` on a computer with 4 processors).\n"
"Otherwise something wrong - for example, too narrow network, too low performan"
"ce client."
msgstr ""
"ベンチマークの実行中は、`node0`のシステムの状態を`top`コマンドなどを使って監視しておきましょう。\n"
"もしベンチマークがGroongaの性能を正しく引き出していれば、GroongaのプロセスはCPUをフルに使い切っているはずです（プロセッサ数4ならば`400"
"%`、といった具合に）。\n"
"そうでない場合は、何かがおかしいです。例えばネットワーク帯域が細すぎるのかもしれませんし、クライアントが非力すぎるのかもしれません。"

msgid "Then you'll get the reference result of the Groonga."
msgstr "これで、対照用のGroongaでの結果を得る事ができます。"

msgid "To confirm the result is valid, check the response of the `status` command:"
msgstr "結果が妥当かどうかを確かめるために、`status`コマンドの結果を確認しましょう："

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/status\" | jq .\n"
"[\n"
"  [\n"
"    0,\n"
"    1412326645.19701,\n"
"    3.76701354980469e-05\n"
"  ],\n"
"  {\n"
"    \"max_command_version\": 2,\n"
"    \"alloc_count\": 158,\n"
"    \"starttime\": 1412326485,\n"
"    \"uptime\": 160,\n"
"    \"version\": \"4.0.6\",\n"
"    \"n_queries\": 1000,\n"
"    \"cache_hit_rate\": 0.49,\n"
"    \"command_version\": 1,\n"
"    \"default_command_version\": 1\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Look at the value of `\"cache_hit_rate\"`.\n"
"If it is far from the expected cache hit rate (ex. `0.5`), something wrong - f"
"or example, too few request patterns.\n"
"Too high cache hit rate produces too high throughput unexpectedly."
msgstr ""
"`\"cache_hit_rate\"`の値に注目してください。\n"
"この値が想定されるキャッシュ率（例えば`0.5`）からかけ離れている場合、何かがおかしいです。例えば、リクエストパターンの数が少なすぎるかも知れません。\n"
"キャッシュヒット率が高すぎる場合、結果のスループットは本来よりも高すぎる値になってしまいます。"

msgid ""
"After that you should stop Groonga to release CPU and RAM resources, if it is "
"running on a Droonga node."
msgstr ""
"Droongaノードの上でGroongaを動かしている場合は、CPU資源とメモリ資源を解放するために、ベンチマーク取得後はGroongaを停止しておきましょ"
"う。"

msgid ""
"~~~\n"
"(on node0)\n"
"% pkill groonga\n"
"~~~"
msgstr ""

msgid "### Benchmark Droonga"
msgstr "### Droongaのベンチマークを行う"

msgid "#### Benchmark Droonga with single node"
msgstr "#### 1ノード構成でのDroongaのベンチマーク"

msgid "Before benchmarking, make your cluster with only one node."
msgstr "ベンチマークの前に、ノードが1つだけの状態にクラスタを設定します。"

msgid ""
"~~~\n"
"(on node1, node2)\n"
"% sudo service droonga-engine stop\n"
"% sudo service droonga-http-server stop\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"To clear effects from previous benchmark, you should restart services before e"
"ach test."
msgstr "前回のベンチマークの影響をなくすために、各ベンチマークの実行前にはサービスを再起動することをおすすめします。"

msgid ""
"After that the endpoint `node0` works as a Droonga cluster with single node.\n"
"Make sure that only one node is actually detected:"
msgstr ""
"これにより、`node0`は1ノード構成のクラスタとして動作するようになります。\n"
"実際にノードが1つだけ認識されていることを確認しましょう:"

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid "Run the benchmark."
msgstr "ベンチマークを実行しましょう。"

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-1node.csv\n"
"~~~"
msgstr ""

msgid ""
"Note that the default port is changed from `10041` (Groonga's HTTP server) to "
"`10042` (Droonga).\n"
"Moreover, the path to the result file also changed."
msgstr ""
"デフォルトのポートが`10041`（GroongaのHTTPサーバのポート）から`10042`（Droongaのポート）に変わっていることに注意して下さい。"
"\n"
"結果の保存先のパスも変わっています。"

msgid ""
"While running, you should monitor the system status of the `node0`, by `top` o"
"r something.\n"
"It may help you to analyze what is the bottleneck."
msgstr ""
"ベンチマークの実行中、`node0`のシステムの状態を`top`コマンドなどで監視しておきましょう。\n"
"これはボトルネックの分析に役立ちます。"

msgid ""
"And, to confirm the result is valid, you should check the actual cache hit rat"
"e:"
msgstr "また、結果が正しいかどうかを確かめるために、実際のキャッシュヒット率を確認しておきましょう："

msgid ""
"~~~\n"
"% curl \"http://node0:10042/statistics/cache\" | jq .\n"
"{\n"
"  \"hitRatio\": 49.830717830807124,\n"
"  \"nHits\": 66968,\n"
"  \"nGets\": 134391\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Look at the value of `\"hitRatio\"`.\n"
"Actual cache hit rate of the HTTP server is reported in percentage like above "
"(the value `49.830717830807124` means `49.830717830807124%`.)\n"
"If it is far from the expected cache hit rate, something wrong."
msgstr ""
"`\"hitRatio\"`の値に注目してください。HTTPサーバにおける実際のキャッシュヒット率は、上記のようにパーセンテージで示されます（`49.83071"
"7830807124`という値はそのまま`49.830717830807124%`ということです）。\n"
"もし値が期待されるキャッシュヒット率と大きく異なっている場合、何かがおかしいです。"

msgid "#### Benchmark Droonga with two nodes"
msgstr "#### 2ノード構成でのDroongaのベンチマーク"

msgid "Before benchmarking, join the second node to the cluster."
msgstr "ベンチマークの前に、2番目のノードをクラスタに参加させます。"

msgid ""
"~~~\n"
"(on node0, node1)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"After that both endpoints `node0` and `node1` work as a Droonga cluster with t"
"wo nodes.\n"
"Make sure that two nodes are actually detected:"
msgstr ""
"これにより、`node0`と`node1`は2ノード構成のDroongaクラスタとして動作するようになります。\n"
"実際にノードが2つ認識されていることを確認しましょう:"

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0,node1 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-2nodes.csv\n"
"~~~"
msgstr ""

msgid "Note that two hosts are specified via the `--default-hosts` option."
msgstr "`--default-hosts` で2つのホストを指定していることに注意して下さい。"

msgid ""
"If you send all requests to single endpoint, `droonga-http-server` will become"
" a bottleneck, because it works as a single process for now.\n"
"Moreover, `droonga-http-server` and `droonga-engine` will scramble for CPU res"
"ources.\n"
"To measure the performance of your Droonga cluster effectively, you should ave"
"rage out CPU load per capita."
msgstr ""
"今の所、`droonga-http-server`はシングルプロセスのため、すべてのリクエストを1つだけのホストに送ると`droonga-http-serv"
"er`がボトルネックとなってしまいます。\n"
"また、`droonga-http-server`と`droonga-engine`がCPU資源を奪い合うことにもなります。\n"
"Droongaクラスタの性能を有効に測定するためには、各ノードのCPU使用率を平滑化する必要があります。"

msgid ""
"Of course, on the production environment, it should be done by a load balancer"
", but It's a hassle to set up a load balancer for just benchmarking.\n"
"Instead, you can specify multiple endpoint host names as a comma-separated lis"
"t for the `--default-hosts` option."
msgstr ""
"もちろん、実際のプロダクション環境ではこのようなリクエストの分配はロードバランサーによって行われるべきですが、ベンチマークのためだけにロードバランサーを設定"
"するのは煩雑です。\n"
"`--default-hosts`オプションにカンマ区切りで複数のホスト名を指定することで、その代替とすることができます。"

msgid "And, the path to the result file also changed."
msgstr "また、結果の保存先のパスも変えています。"

msgid ""
"Don't forget to monitor system status of both nodes while benchmarking.\n"
"If only one node is busy and another is idling, something wrong - for example,"
" they are not working as a cluster.\n"
"You also must check the actual cache hit rate of all nodes."
msgstr ""
"ベンチマークの実行中、両方のノードのシステムの状態を監視することを忘れないでください。\n"
"もし片方のノードだけに負荷がかかっていてもう片方がアイドル状態なのであれば、両者が1つのクラスタとして働いていないなどのように、何か異常が起こっていると分か"
"ります。\n"
"すべてのノードの実際のキャッシュヒット率も忘れずに確認しておきましょう。"

msgid "#### Benchmark Droonga with three nodes"
msgstr "#### 3ノード構成でのDroongaのベンチマーク"

msgid "Before benchmarking, join the last node to the cluster."
msgstr "ベンチマークの前に、最後のノードをクラスタに参加させましょう。"

msgid ""
"~~~\n"
"(on node0, node1)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1,node2\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"After that all endpoints `node0`, `node1`, and `node2` work as a Droonga clust"
"er with three nodes.\n"
"Make sure that three nodes are actually detected:"
msgstr ""
"これで、`node0`, `node1`, `node2`のすべてのノードが3ノード構成のクラスタとして動作するようになります。\n"
"実際にノードが3つ認識されていることを確認しましょう:"

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node2:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0,node1,node2 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-3nodes.csv\n"
"~~~"
msgstr ""

msgid ""
"Note that both `--default-hosts` and `--output-path` are changed again.\n"
"Monitoring of system status and checking cache hit rate of all nodes are also "
"important."
msgstr ""
"また`--default-hosts`と`--output-path`の指定も変えていることに注意して下さい。\n"
"各ノードのシステムの状態の監視と、実際のキャッシュヒット率の確認も忘れてはいけません。"

msgid "## Analyze the result"
msgstr "## 結果を分析する"

msgid "OK, now you have four results:"
msgstr "これで、手元に4つの結果が集まりました:"

msgid ""
" * `groonga-result.csv`\n"
" * `droonga-result-1node.csv`\n"
" * `droonga-result-2nodes.csv`\n"
" * `droonga-result-3nodes.csv`"
msgstr ""

msgid "[As described](#how-to-analyze), you can analyze them."
msgstr "[先に述べた通り](#how-to-analyze)、これらを使って傾向を分析することができます。"

msgid "For example, you can plot a graph from these results like:"
msgstr "例えば、これらの結果は以下のようにグラフ化できます:"

msgid ""
"![A layered graph of latency](/images/tutorial/benchmark/latency-mixed-1.0.8.p"
"ng)"
msgstr "![それぞれの場合のレイテンシーを重ねたグラフ](/images/tutorial/benchmark/latency-mixed-1.0.8.png)"

msgid "You can explain this graph of latency as:"
msgstr "このレイテンシーのグラフは以下のように読み取れます："

msgid ""
" * Minimum latency of Droonga is larger than Groonga.\n"
"   There are some overhead in Droonga.\n"
" * Latency of multiple nodes Droonga slowly increases than Groonga.\n"
"   Droonga can process more requests in same time without extra waiting time."
msgstr ""
" * Droongaのレイテンシーの下限はGroongaのそれよりも大きい。\n"
"   Droongaにはオーバーヘッドがある。\n"
" * 複数ノードのDroongaのレイテンシーはGroongaに比べると緩やかに増大している。\n"
"   Droongaは余計な待ち時間無しでより多くのリクエストを同時に処理できる。"

msgid ""
"![A layered graph of throughput](/images/tutorial/benchmark/throughput-mixed-1"
".0.8.png)"
msgstr ""
"![それぞれの場合のスループットを重ねたグラフ](/images/tutorial/benchmark/throughput-mixed-1.0.8.png"
")"

msgid "You can explain this graph of throughput as:"
msgstr "このスループットのグラフは以下のように読み取れます："

msgid ""
" * Graphs of Groonga and single node Droonga are alike.\n"
"   There is less performance loss between Groonga and Droonga.\n"
" * Maximum throughput of Droonga is incdeased by number of nodes."
msgstr ""
" * GroongaのグラフとDroongaの単一ノード時のグラフは似通っている。\n"
"   GroongaとDroongaの間での性能の劣化はごくわずかである。\n"
" * Droongaのスループット性能はノード数によって増大する。"

msgid ""
"(Note: Performance results fluctuate from various factors.\n"
"This graph is just an example on a specific version, specific environment.)"
msgstr ""
"(注意: 性能測定の結果は様々な要因によって変動します。\n"
"これはあくまで特定のバージョン、特定の環境での結果の例です。)"

msgid "## Conclusion"
msgstr "## まとめ"

msgid ""
"In this tutorial, you did prepare a reference [Groonga][] server and [Droonga]"
"[] cluster.\n"
"And, you studied how to prepare request patterns, how measure your systems, an"
"d how analyze the result."
msgstr ""
"このチュートリアルでは、比較対照としての[Groonga][]サーバと、[Droonga]クラスタを用意しました。\n"
"また、リクエストパターンを用意する手順、システムの性能の測定方法、結果の分析方法なども学びました。"

msgid ""
"  [Ubuntu]: http://www.ubuntu.com/\n"
"  [CentOS]: https://www.centos.org/\n"
"  [Droonga]: https://droonga.org/\n"
"  [Groonga]: http://groonga.org/\n"
"  [drnbench]: https://github.com/droonga/drnbench/\n"
"  [wikipedia-search]: https://github.com/droonga/wikipedia-search/\n"
"  [command reference]: ../../reference/commands/"
msgstr ""
